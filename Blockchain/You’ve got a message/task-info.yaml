type: edu
custom_name: stage4
files:
- name: test/BlockchainTest.java
  visible: false
  text: |
    import blockchain.Main;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testcase.TestCase;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.stream.Collectors;


    class BlockParseException extends Exception {
        BlockParseException(String msg) {
            super(msg);
        }
    }


    class Block {

        int id;
        long timestamp;
        long magic;
        String hashprev;
        String hash;

        static Block parseBlock(String strBlock) throws BlockParseException {
            if (strBlock.length() == 0) {
                return null;
            }

            if (!(strBlock.contains("Block:")
                && strBlock.contains("Timestamp:"))) {

                return null;
            }

            Block block = new Block();

            List<String> lines = strBlock
                .lines()
                .map(String::strip)
                .filter(e -> e.length() > 0)
                .collect(Collectors.toList());

            if (lines.size() < 12) {
                throw new BlockParseException("Every block should " +
                    "contain at least 12 lines of data");
            }

            if (!lines.get(0).equals("Block:")) {
                throw new BlockParseException("First line of every block " +
                    "should be \"Block:\"");
            }

            if (!lines.get(1).startsWith("Created by")) {
                throw new BlockParseException("Second line of every block " +
                    "should start with \"Created by\"");
            }

            if (!lines.get(2).startsWith("Id:")) {
                throw new BlockParseException("Third line of every block " +
                    "should start with \"Id:\"");
            }

            String id = lines.get(2).split(":")[1]
                .strip().replace("-", "");
            boolean isNumeric = id.chars().allMatch(Character::isDigit);

            if (!isNumeric) {
                throw new BlockParseException("Id should be a number");
            }

            block.id = Integer.parseInt(id);



            if (!lines.get(3).startsWith("Timestamp:")) {
                throw new BlockParseException("4-th line of every block " +
                    "should start with \"Timestamp:\"");
            }

            String timestamp = lines.get(3).split(":")[1]
                .strip().replace("-", "");
            isNumeric = timestamp.chars().allMatch(Character::isDigit);

            if (!isNumeric) {
                throw new BlockParseException("Timestamp should be a number");
            }

            block.timestamp = Long.parseLong(timestamp);


            if (!lines.get(4).startsWith("Magic number:")) {
                throw new BlockParseException("5-th line of every block " +
                    "should start with \"Magic number:\"");
            }

            String magic = lines.get(4).split(":")[1]
                .strip().replace("-", "");
            isNumeric = magic.chars().allMatch(Character::isDigit);

            if (!isNumeric) {
                throw new BlockParseException("Magic number should be a number");
            }

            block.magic = Long.parseLong(magic);



            if (!lines.get(5).equals("Hash of the previous block:")) {
                throw new BlockParseException("6-th line of every block " +
                    "should be \"Hash of the previous block:\"");
            }

            if (!lines.get(7).equals("Hash of the block:")) {
                throw new BlockParseException("8-th line of every block " +
                    "should be \"Hash of the block:\"");
            }

            String prevhash = lines.get(6).strip();
            String hash = lines.get(8).strip();

            if (!(prevhash.length() == 64 || prevhash.equals("0"))
                || !(hash.length() == 64)) {

                throw new BlockParseException("Hash length should " +
                    "be equal to 64 except \"0\"");
            }

            block.hash = hash;
            block.hashprev = prevhash;

            if (!lines.get(9).startsWith("Block data:")) {
                throw new BlockParseException("10-th line of every block " +
                    "should start with \"Block data:\"");
            }

            return block;
        }


        static List<Block> parseBlocks(String output) throws BlockParseException {
            String[] strBlocks = output.split("\n\n");

            List<Block> blocks = new ArrayList<>();

            for (String strBlock : strBlocks) {
                Block block = parseBlock(strBlock.strip());
                if (block != null) {
                    blocks.add(block);
                }
            }

            return blocks;
        }
    }

    class Clue {
        String zeros;
        Clue(int n) {
            zeros = "0".repeat(n);
        }
    }


    public class BlockchainTest extends StageTest<Clue> {
        public BlockchainTest() {
            super(Main.class);
        }

        List<String> previousOutputs = new ArrayList<>();

        @Override
        public List<TestCase<Clue>> generate() {
            return List.of(
                new TestCase<>(),
                new TestCase<>()
            );
        }

        @Override
        public CheckResult check(String reply, Clue clue) {

            if (previousOutputs.contains(reply)) {
                return new CheckResult(false,
                    "You already printed this text in the previous tests");
            }

            previousOutputs.add(reply);

            List<Block> blocks;
            try {
                blocks = Block.parseBlocks(reply);
            } catch (BlockParseException ex) {
                return new CheckResult(false, ex.getMessage());
            } catch (Exception ex) {
                return CheckResult.wrong("");
            }

            if (blocks.size() != 5) {
                return new CheckResult(false,
                    "You should output 5 blocks, found " + blocks.size());
            }

            for (int i = 1; i < blocks.size(); i++) {
                Block curr = blocks.get(i - 1);
                Block next = blocks.get(i);

                if (curr.id + 1 != next.id) {
                    return new CheckResult(false,
                        "Id`s of blocks should increase by 1");
                }

                if (next.timestamp < curr.timestamp) {
                    return new CheckResult(false,
                        "Timestamp`s of blocks should increase");
                }

                if (!next.hashprev.equals(curr.hash)) {
                    return new CheckResult(false, "Two hashes aren't equal, " +
                        "but should");
                }
            }


            return CheckResult.correct();
        }
    }
  learner_created: false
- name: src/blockchain/Main.java
  visible: true
  text: |-
    package blockchain;

    public class Main {
        public static void main(String args[]){
            BlockChain blockChain = new BlockChain();

            for(int i=0; i<5; i++){
                Block block = blockChain.createBlock();
                printBlock(block);
                System.out.print( (i < 4) ? "\n" : "");
            }
        }

        private static void printBlock(Block block){
            System.out.println("Block:");
            System.out.println("Id: " + block.getId());
            System.out.println("Timestamp: " + block.getTimestamp());
            System.out.println("Hash of the previous block: \n" + block.getPrevBlockHash());
            System.out.println("Hash of the block: \n" + block.getHash());
        }
    }
  learner_created: false
- name: src/blockchain/Block.java
  visible: true
  text: |
    package blockchain;

    import java.util.Date;

    public class Block {

        private final String prevBlockHash;
        private final long id;
        private final long timestamp;
        private final String hash;

        public Block(final long id, final String prevBlockHash){
            this.prevBlockHash = prevBlockHash;
            this.id = id;
            timestamp = new Date().getTime();
            hash = StringUtil.applySha256(toString());
        }

        @Override
        public String toString(){
            StringBuilder str = new StringBuilder();
            str.append(prevBlockHash);
            str.append(id);
            str.append(timestamp);
            return str.toString();
        }

        public long getId(){
            return id;
        }

        public long getTimestamp(){
            return timestamp;
        }

        public String getHash(){
            return hash;
        }

        public String getPrevBlockHash(){
            return prevBlockHash;
        }
    }
  learner_created: false
- name: src/blockchain/miner/MinerFactory.java
  visible: true
  text: |
    package blockchain.miner;

    import blockchain.*;

    public class MinerFactory {
        private long runningMinerId;
        private Blockchain blockchain;

        public MinerFactory(Blockchain blockchain) {
            this.blockchain = blockchain;
            runningMinerId = 1;
        }

        public Miner newMiner() {
            return Miner.of(blockchain, runningMinerId++);
        }
    }
  learner_created: true
- name: src/blockchain/Blockchain.java
  visible: true
  text: |-
    package blockchain;

    import java.io.Serializable;
    import java.util.ArrayList;
    import java.util.Queue;
    import java.util.concurrent.ConcurrentLinkedQueue;
    import blockchain.miner.Miner;

    public class Blockchain implements Serializable {
        private long runningBlockId;
        private String runningPrevBlockHash;
        private final ArrayList<Block> chain;
        private final Queue<Block> unprocessedBlocks;
        private BlockchainDriver creator;

        private int noOfStartZerosForHash;
        private String requiredPrefixForHash;

        private static final int blockCreationFrequencyPerMinute = 3;
        private static final int fixedMiningTimeMs = (int) ((60 * 1e3) / blockCreationFrequencyPerMinute);
        /**
         * 15% of deviation from fixed time is acceptable
         */
        private static final int acceptableDeviationInMiningTimeMs = (int) ((fixedMiningTimeMs * 15) / 100);

        private Block currentMiningBlock;
        private long currentMiningBlockStartTimeMs;
        private long currentMiningBlockEndTimeMs;

        private Blockchain() {
            runningBlockId = 1;
            runningPrevBlockHash = "0";
            chain = new ArrayList<>();
            unprocessedBlocks = new ConcurrentLinkedQueue<>();

            noOfStartZerosForHash = 0;
            requiredPrefixForHash = "";
        }

        public void addBlock() {
            Block block = Block.with(runningBlockId);
            if(runningPrevBlockHash != null) {
                block.setPrevBlockHash(runningPrevBlockHash);
                runningPrevBlockHash = null;
            }

            if(unprocessedBlocks.isEmpty()) {
                currentMiningBlock = block;
                currentMiningBlockStartTimeMs = System.currentTimeMillis();
            }
            unprocessedBlocks.add(block);
            runningBlockId++;
            creator.saveBlockchain();
        }

        public static Blockchain generateBlockchain(Object caller) {
            if(!(caller instanceof BlockchainDriver)) throw new IllegalCallerException();
            Blockchain blockchain = new Blockchain();
            blockchain.creator = (BlockchainDriver) caller;
            return blockchain;
        }

        public boolean isValid() {
            long id = 1;
            String prevBlockHash = "0";

            for (Block block : chain) {
                if (block.getId() != id) return false;
                if (!block.getPrevBlockHash().equals(prevBlockHash)) return false;
                if (!block.isConsistent()) return false;
                String presentHash = block.getHash();

                id += 1;
                prevBlockHash = presentHash;
            }

            return true;
        }

        public synchronized boolean submitBlock(Block block, Object caller) {
            if (!(caller instanceof Miner)) {
                throw new IllegalCallerException();
            }

            currentMiningBlockEndTimeMs = System.currentTimeMillis();

            if (!areSameBlocks(currentMiningBlock, block)) { return false; }
            if (!block.getHash().startsWith(requiredPrefixForHash)) { return false; }
            if (!block.isConsistent()) { return false; }

            block.setTimeTookMs(currentMiningBlockEndTimeMs - block.getTimestamp());
            block.setTimeTookForMiningMs(currentMiningBlockEndTimeMs - currentMiningBlockStartTimeMs);
            chain.add(block);
            unprocessedBlocks.poll();
            updateMiningConstraints();

            runningPrevBlockHash = block.getHash();

            Block nextUnprocessedBlock = unprocessedBlocks.peek();
            if (nextUnprocessedBlock != null) {
                nextUnprocessedBlock.setPrevBlockHash(runningPrevBlockHash);
                runningPrevBlockHash = null;
            }
            currentMiningBlock = nextUnprocessedBlock;

            creator.saveBlockchain();
            currentMiningBlockStartTimeMs = System.currentTimeMillis();
            return true;
        }

        public Block getUnprocessedBlock() {
            if(currentMiningBlock == null) return null;
            return (Block) currentMiningBlock.clone();
        }

        public long getLength() { return chain.size(); }

        public Block getBlock(int index) { return chain.get(index); }

        public String getRequiredPrefixForHash() { return requiredPrefixForHash; }

        public static int getBlockCreationFrequencyPerMinute() { return blockCreationFrequencyPerMinute; }

        public static int getFixedMiningTimeMs() { return fixedMiningTimeMs; }

        public static int getAcceptableDeviationInMiningTimeMs() { return acceptableDeviationInMiningTimeMs; }

        private static boolean areSameBlocks(Block b1, Block b2) {
            if (b1 == b2) { return true; }

            if (b1.getClass() != b2.getClass()) { return false; }
            if (b1.getId() != b2.getId()) { return false; }
            if (b1.getTimestamp() != b2.getTimestamp()) { return false; }
            if (!b1.getPrevBlockHash().equals(b2.getPrevBlockHash())) { return false; }

            return true;
        }

        private void updateMiningConstraints() {
            long timeTookForMining = currentMiningBlockEndTimeMs - currentMiningBlockStartTimeMs;

            if (timeTookForMining >= (fixedMiningTimeMs - acceptableDeviationInMiningTimeMs)
                && timeTookForMining <= (fixedMiningTimeMs + acceptableDeviationInMiningTimeMs)) {
                return;
            }

            if(timeTookForMining < (fixedMiningTimeMs - acceptableDeviationInMiningTimeMs)) {
                noOfStartZerosForHash++;
                requiredPrefixForHash = requiredPrefixForHash.concat("0");
                return;
            }

            noOfStartZerosForHash = Math.max(0, --noOfStartZerosForHash);
            requiredPrefixForHash = "0".repeat(noOfStartZerosForHash);
        }
    }
  learner_created: true
- name: src/blockchain/BlockchainDriver.java
  visible: true
  text: |-
    package blockchain;

    import java.io.IOException;
    import blockchain.utils.*;

    public class BlockchainDriver {
        String fileName;
        Blockchain blockchain;

        private BlockchainDriver() {
            fileName = null;
            blockchain = null;
        }

        public static BlockchainDriver newDriver() {
            BlockchainDriver driver = new BlockchainDriver();
            driver.fileName = driver.toString();
            return driver;
        }

        public Blockchain getBlockchain() {
            if (blockchain != null && blockchain.isValid()) { return blockchain; }

            try {
                blockchain = (Blockchain) SerializationUtils.deserialize(fileName);
            } catch(Exception ignored) {

            } finally {
                if (blockchain == null || !blockchain.isValid()) {
                    blockchain = Blockchain.generateBlockchain(this);
                }
            }

            return blockchain;
        }

        public boolean saveBlockchain() {
            try {
                SerializationUtils.serialize(blockchain, fileName);
                return true;
            } catch (IOException ignored) {
                return false;
            }
        }
    }
  learner_created: true
- name: src/blockchain/utils/SerializationUtils.java
  visible: true
  text: |
    package blockchain.utils;

    import java.io.IOException;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.BufferedInputStream;
    import java.io.BufferedOutputStream;

    public class SerializationUtils {
        public static void serialize(Object obj, String fileName) throws IOException {
            FileOutputStream fos = new FileOutputStream(fileName);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(obj);
            oos.close();
        }

        public static Object deserialize(String fileName) throws IOException, ClassNotFoundException {
            FileInputStream fis = new FileInputStream(fileName);
            BufferedInputStream bis = new BufferedInputStream(fis);
            ObjectInputStream ois = new ObjectInputStream(bis);
            Object obj = ois.readObject();
            ois.close();
            return obj;
        }
    }
  learner_created: true
- name: src/blockchain/miner/Miner.java
  visible: true
  text: |-
    package blockchain.miner;

    import java.util.Random;
    import blockchain.*;
    import blockchain.utils.*;

    public class Miner implements Runnable {

        private Blockchain blockchain;
        private Block currentProcessingBlock;
        private Random random;
        private long id;
        private static final int BLINDREPITITIONS = 100;
        private static final int SLEEPWHENNOWORKMS = 1000;

        private Miner(Blockchain blockchain, long id) {
            this.blockchain = blockchain;
            this.id = id;
            currentProcessingBlock = null;
            random = null;
        }


        static Miner of(Blockchain blockchain, long id) {
            return new Miner(blockchain, id);
        }

        @Override
        public void run() {
            while (true) {
                updateCurrentProcessingBlock();
                if (currentProcessingBlock == null) {
                    try {
                        Thread.sleep(SLEEPWHENNOWORKMS);
                    } catch (InterruptedException ignored) {
                        return;
                    }
                    continue;
                }
                boolean successful = blindMining();
                if (successful) {
                    currentProcessingBlock.setMinerId(id);
                    blockchain.submitBlock(currentProcessingBlock, this);
                }
            }
        }

        private boolean blindMining() {
            String requiredPrefix = blockchain.getRequiredPrefixForHash();
            for (int i = 0; i < BLINDREPITITIONS; i++) {
                currentProcessingBlock.setMagicNum(random.nextInt());
                String computedHash = StringUtils.applySha256(currentProcessingBlock.toString());
                if (computedHash.startsWith(requiredPrefix)) {
                    currentProcessingBlock.setHash(computedHash);
                    return true;
                }
            }
            return false;
        }

        private void updateCurrentProcessingBlock() {
            Block block = blockchain.getUnprocessedBlock();
            if (currentProcessingBlock == null || !currentProcessingBlock.equals(block)) {
                currentProcessingBlock = block;
                random = new Random();
            }
        }
    }
  learner_created: true
- name: src/blockchain/utils/StringUtils.java
  visible: true
  learner_created: true
- name: src/blockchain/client/Client.java
  visible: true
  learner_created: true
- name: src/blockchain/client/ClientFactory.java
  visible: true
  learner_created: true
- name: src/blockchain/Message.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/50/stages/274/implement
status: Failed
record: 4
